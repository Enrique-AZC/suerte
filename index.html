<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vela de la suerte</title>
<style>
  :root{
    --accent: #00d166; /* verde para "Buena suerte activada" */
    --bg: #000;
    --wax: #ffffff;
    --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Helvetica,Arial,sans-serif;}
  #container{width:100%;height:100%;position:relative;touch-action:none;}

/* Overlay UI elements (minimal, unobtrusive) */
  .caption{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:38px;
    color:var(--accent);
    font-weight:600;
    font-size:18px;
    letter-spacing:0.6px;
    opacity:0;
    pointer-events:none;
    text-shadow:0 0 10px rgba(0,0,0,0.7);
  }

  .phrase {
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:160px;
    color:#fff;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.06);
    padding:12px 18px;
    border-radius:10px;
    font-size:18px;
    opacity:0;
    pointer-events:none;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
  }

  /* small hint for mobile orientation (hidden by default) */
  .note{
    position:absolute;
    top:18px;
    left:18px;
    color: rgba(255,255,255,0.12);
    font-size:12px;
    user-select:none;
  }

  /* subtle vignette so candle feels centered */
  .vignette {
    position:absolute;left:0;top:0;width:100%;height:100%;
    background: radial-gradient(ellipse at center, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.6) 70%);
    pointer-events:none;
  }

  /* appear/fade animations */
  .fade-in { animation:fadeIn .6s ease forwards; }
  .float-up { animation:floatUp .9s cubic-bezier(.2,.9,.2,1) forwards; }
  @keyframes fadeIn { from{opacity:0; transform: translateY(6px);} to{opacity:1; transform:none;} }
  @keyframes floatUp { from{opacity:0; transform: translateY(10px);} to{opacity:1; transform: translateY(-8px);} }

  /* responsiveness tweaks */
  @media (max-width:600px){
    .phrase{font-size:16px; bottom:130px; padding:10px 14px;}
    .caption{font-size:16px; bottom:28px;}
  }
</style>
</head>
<body>
  <div id="container"></div>
  <div class="vignette"></div>
  <div class="phrase" id="phraseBox"></div>
  <div class="caption" id="caption">Buena suerte activada</div>
  <div class="note"> </div>

  <!-- three.js modules -->
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  const container = document.getElementById('container');
  const phraseBox = document.getElementById('phraseBox');
  const caption = document.getElementById('caption');

  // phrases (easter egg)
  const PHRASES = ["Estrellita","Guapetona","Alcaldesa de Bañón","Ángel","Te quiero"];

  // renderer
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // scene & camera
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.025);
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,1.2,3);

  // controls (subtle orbit, auto-rotate)
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.minDistance = 1.6;
  controls.maxDistance = 6;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.2;
  controls.maxPolarAngle = Math.PI/2.2;
  controls.minPolarAngle = Math.PI/6;

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.25);
  scene.add(hemi);

  // subtle ambient warm fill
  const ambient = new THREE.AmbientLight(0xffffff, 0.1);
  scene.add(ambient);

  // ground reflection plane (very subtle)
  const groundGeo = new THREE.PlaneGeometry(20,20);
  const groundMat = new THREE.MeshStandardMaterial({ color:0x040404, roughness:1, metalness:0 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -1.1;
  scene.add(ground);

  // Candle body (white wax, slight subsurface effect via emissive + roughness map trick)
  const waxMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.7,
    metalness: 0.0,
    // slight warm subsurface-ish tint via emissive
    emissive: new THREE.Color(0x080808),
    emissiveIntensity: 0.02
  });

  const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 1.1, 32), waxMat);
  candle.position.y = -0.05;
  scene.add(candle);

  // slight bevel (top indentation)
  const topIndentGeo = new THREE.CylinderGeometry(0.18, 0.3, 0.12, 32);
  const topIndent = new THREE.Mesh(topIndentGeo, waxMat);
  topIndent.position.y = 0.45;
  topIndent.rotation.x = Math.PI;
  scene.add(topIndent);

  // wick (thin cylinder)
  const wickMat = new THREE.MeshStandardMaterial({ color:0x222222, roughness:0.6 });
  const wick = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.12,12), wickMat);
  wick.position.set(0, 0.52, 0);
  scene.add(wick);

  // add small melted wax drip shapes (optional subtle)
  const dripGeo = new THREE.SphereGeometry(0.06, 16, 12);
  const drip1 = new THREE.Mesh(dripGeo, waxMat); drip1.position.set(0.22, 0.22, 0.05); drip1.scale.set(1,1.3,0.8); scene.add(drip1);
  const drip2 = new THREE.Mesh(dripGeo, waxMat); drip2.position.set(-0.18, 0.12, -0.08); drip2.scale.set(0.9,1.2,0.7); scene.add(drip2);

  // FLAME: built with a custom shader on a double-sided plane that warps and fades
  const flameGeo = new THREE.PlaneGeometry(0.25, 0.6, 16, 32);

  // Simple noise function in shader (GLSL)
  const flameMat = new THREE.ShaderMaterial({
    transparent: true,
    side: THREE.DoubleSide,
    uniforms: {
      time: { value: 0 },
      color1: { value: new THREE.Color(0xfff1b8) }, // core
      color2: { value: new THREE.Color(0xffa844) }, // mid
      color3: { value: new THREE.Color(0xff3e00) }, // tips
      opacity: { value: 1.0 }
    },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vPos;
      void main(){
        vUv = uv;
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      precision mediump float;
      varying vec2 vUv;
      uniform float time;
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 color3;
      // Classic 2D simplex-ish noise (cheap)
      float hash(vec2 p){ p = fract(p*vec2(123.34, 456.21)); p += dot(p, p+45.32); return fract(p.x*p.y); }
      float noise(vec2 p){
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash(i);
        float b = hash(i + vec2(1.0,0.0));
        float c = hash(i + vec2(0.0,1.0));
        float d = hash(i + vec2(1.0,1.0));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
      }
      void main(){
        vec2 uv = vUv;
        // Move noise upward for flicker
        float n = noise(vec2(uv.x*4.0 + time*1.2, uv.y*8.0 - time*2.0));
        // flame mask: triangular shape
        float mask = smoothstep(0.0, 0.02, uv.x) * (1.0 - uv.y);
        float shape = smoothstep(0.0, 0.9, (1.0 - uv.y) * (1.0 - abs(uv.x-0.5)*2.0));
        // vertical gradient
        float t = uv.y;
        // color blending with noise and vertical position
        vec3 col = mix(color1, color2, smoothstep(0.2, 0.6, t + n*0.15));
        col = mix(col, color3, smoothstep(0.6, 0.95, t + n*0.25));
        float alpha = shape * (0.9 - n*0.5) * smoothstep(0.0, 0.95, 1.0 - uv.y);
        alpha *= 1.0 - smoothstep(0.9, 1.0, uv.y);
        // soften outer edges
        alpha *= smoothstep(0.0, 0.7, 1.0 - abs(uv.x-0.5)*2.0);
        if(alpha < 0.01) discard;
        gl_FragColor = vec4(col, alpha);
      }
    `
  });

  // plane for flame (two planes slightly rotated to look volumetric)
  const flamePlane1 = new THREE.Mesh(flameGeo, flameMat);
  flamePlane1.position.set(0, 0.78, 0);
  flamePlane1.rotation.y = Math.PI * 0.02;
  scene.add(flamePlane1);

  const flamePlane2 = flamePlane1.clone();
  flamePlane2.rotation.y = -Math.PI * 0.18;
  flamePlane2.material = flameMat.clone();
  flamePlane2.material.side = THREE.DoubleSide;
  scene.add(flamePlane2);

  // point light to emulate flame glow
  const flameLight = new THREE.PointLight(0xffcc88, 1.2, 6, 2);
  flameLight.position.set(0,0.9,0);
  scene.add(flameLight);

  // small subtle particles around flame (sparks)
  const sparksGeo = new THREE.BufferGeometry();
  const sparksCount = 40;
  const sparksPos = new Float32Array(sparksCount*3);
  for(let i=0;i<sparksCount;i++){
    sparksPos[i*3+0] = (Math.random()-0.5)*0.15;
    sparksPos[i*3+1] = 0.6 + Math.random()*0.4;
    sparksPos[i*3+2] = (Math.random()-0.5)*0.15;
  }
  sparksGeo.setAttribute('position', new THREE.BufferAttribute(sparksPos, 3));
  const sparksMat = new THREE.PointsMaterial({ color:0xffddbb, size:0.02, transparent:true, opacity:0.9 });
  const sparks = new THREE.Points(sparksGeo, sparksMat);
  scene.add(sparks);

  // subtle reflection/emissive on top of candle
  const topGlowGeo = new THREE.CircleGeometry(0.12, 32);
  const topGlowMat = new THREE.MeshBasicMaterial({ color: 0xfff4d6, transparent:true, opacity:0.06 });
  const topGlow = new THREE.Mesh(topGlowGeo, topGlowMat);
  topGlow.rotation.x = -Math.PI/2;
  topGlow.position.y = 0.52;
  scene.add(topGlow);

  // helper for raycasting
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  // Animation & flicker parameters
  let clock = new THREE.Clock();

  // activation state
  let activated = false;

  // interaction: on click or tap, raycast at flame area
  function onPointerDown(e){
    e.preventDefault();
    const rect = renderer.domElement.getBoundingClientRect();
    let clientX, clientY;
    if(e.touches && e.touches.length) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    // check intersection with flame planes
    const intersects = raycaster.intersectObjects([flamePlane1, flamePlane2], true);
    if(intersects.length > 0){
      activateEasterEgg();
    }
  }

  // Activation behavior: choose random phrase, show it, show caption
  function activateEasterEgg(){
    if(activated) return; // only first activation triggers UI (optional: allow repeated)
    activated = true;
    const phrase = PHRASES[Math.floor(Math.random()*PHRASES.length)];
    phraseBox.textContent = phrase;
    phraseBox.classList.add('fade-in','float-up');
    phraseBox.style.opacity = '1';
    caption.classList.add('fade-in');
    caption.style.opacity = '1';
    // slight camera nudge toward candle
    gsapCameraZoom();
    // small gentle pulse in flame light
    // (we'll handle flicker in animation loop as well)
  }

  // camera push effect using simple tween (no external library)
  let camTween = null;
  function gsapCameraZoom(){
    const start = { z: camera.position.z, y: camera.position.y };
    const target = { z: Math.max(1.8, camera.position.z-0.6), y: camera.position.y - 0.08 };
    const duration = 700;
    const t0 = performance.now();
    function tick(now){
      const t = Math.min(1, (now - t0)/duration);
      const ease = (1 - Math.cos(Math.PI * t)) / 2;
      camera.position.z = start.z + (target.z - start.z) * ease;
      camera.position.y = start.y + (target.y - start.y) * ease;
      if(t < 1) requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  // render loop
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // update flame shader time
    flameMat.uniforms.time.value = t;
    flamePlane2.material.uniforms.time.value = t;

    // flicker light intensity
    flameLight.intensity = 1.05 + Math.sin(t*18.0)*0.15 + (Math.random()*0.03);
    flameLight.color.setHSL(0.10, 1.0, 0.6 + Math.sin(t*9.0)*0.02);

    // sparks motion (simple upward movement)
    const pos = sparks.geometry.attributes.position.array;
    for(let i=0;i<sparksCount;i++){
      pos[i*3+1] += 0.001 + Math.sin(t*2.0 + i)*0.0006;
      if(pos[i*3+1] > 1.4) pos[i*3+1] = 0.6 + Math.random()*0.2;
    }
    sparks.geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
  }

  // resize handling
  window.addEventListener('resize', ()=> {
    const w = window.innerWidth, h = window.innerHeight;
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
    renderer.setSize(w,h);
  });

  // pointer event listeners
  renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
  renderer.domElement.addEventListener('touchstart', onPointerDown, false);

  // init & start
  animate();

  // subtle preload: animate initial camera distance a little (floating feel)
  let floatStart = performance.now();
  (function floatCameraLoop(){
    const now = performance.now();
    const dt = (now - floatStart)/1000;
    camera.position.x = Math.sin(dt*0.25) * 0.08;
    camera.position.z = 3 + Math.cos(dt*0.15) * 0.04;
    requestAnimationFrame(floatCameraLoop);
  })();

  // small note: adjust mobile behaviour
  // remove auto-rotate if user interacts
  renderer.domElement.addEventListener('pointerdown', ()=> { controls.autoRotate = false; }, { once:true });

  // ensure shader uniform exists for cloned material
  flamePlane2.material.uniforms = flamePlane2.material.uniforms || flameMat.uniforms;

  // initial subtle intro: fade-in renderer canvas
  renderer.domElement.style.opacity = 0;
  renderer.domElement.style.transition = 'opacity 800ms ease';
  setTimeout(()=> { renderer.domElement.style.opacity = 1; }, 120);

  </script>
</body>
</html>
